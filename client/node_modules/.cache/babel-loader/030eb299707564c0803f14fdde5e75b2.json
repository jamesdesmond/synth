{"ast":null,"code":"import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  outputChannelCount: undefined,\n  parameterData: {},\n  processorOptions: {}\n};\n\nconst createChannelCount = length => {\n  const channelCount = [];\n\n  for (let i = 0; i < length; i += 1) {\n    channelCount.push(1);\n  }\n\n  return channelCount;\n};\n\nconst sanitizedOptions = options => {\n  return { ...options,\n    outputChannelCount: options.outputChannelCount !== undefined ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ?\n    /*\n     * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n     * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n     * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n     */\n    [options.channelCount] : createChannelCount(options.numberOfOutputs)\n  };\n};\n\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n  return class AudioWorkletNode extends audioNodeConstructor {\n    constructor(context, name, options = DEFAULT_OPTIONS) {\n      const nativeContext = getNativeContext(context);\n      const isOffline = isNativeOfflineAudioContext(nativeContext);\n      const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS,\n        ...options\n      });\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === undefined ? undefined : nodeNameToProcessorConstructorMap.get(name);\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, this);\n      }\n    }\n\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n\n    get parameters() {\n      if (this._parameters === null) {\n        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n        return this._nativeAudioWorkletNode.parameters;\n      }\n\n      return this._parameters;\n    }\n\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n\n  };\n};","map":{"version":3,"sources":["/Users/jamescoyne/Desktop/synth-master/client/node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js"],"names":["NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","ReadOnlyMap","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","outputChannelCount","undefined","parameterData","processorOptions","createChannelCount","length","i","push","sanitizedOptions","options","createAudioWorkletNodeConstructor","addUnrenderedAudioWorkletNode","audioNodeConstructor","createAudioParam","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","getNativeContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","wrapEventListener","AudioWorkletNode","constructor","context","name","nativeContext","isOffline","mergedOptions","nodeNameToProcessorConstructorMap","get","processorConstructor","nativeAudioWorkletNode","baseLatency","audioWorkletNodeRenderer","parameters","forEach","nativeAudioParam","nm","audioParam","_nativeAudioWorkletNode","_onprocessorerror","_parameters","onprocessorerror","value","wrappedListener","nativeOnProcessorError","port"],"mappings":"AAAA,SAASA,uCAAT,QAAwD,YAAxD;AACA,SAASC,WAAT,QAA4B,kBAA5B;AACA,MAAMC,eAAe,GAAG;AACpBC,EAAAA,YAAY,EAAE,CADM;AAEpB;AACAC,EAAAA,gBAAgB,EAAE,UAHE;AAIpBC,EAAAA,qBAAqB,EAAE,UAJH;AAKpBC,EAAAA,cAAc,EAAE,CALI;AAMpBC,EAAAA,eAAe,EAAE,CANG;AAOpBC,EAAAA,kBAAkB,EAAEC,SAPA;AAQpBC,EAAAA,aAAa,EAAE,EARK;AASpBC,EAAAA,gBAAgB,EAAE;AATE,CAAxB;;AAWA,MAAMC,kBAAkB,GAAIC,MAAD,IAAY;AACnC,QAAMV,YAAY,GAAG,EAArB;;AACA,OAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,IAAI,CAAjC,EAAoC;AAChCX,IAAAA,YAAY,CAACY,IAAb,CAAkB,CAAlB;AACH;;AACD,SAAOZ,YAAP;AACH,CAND;;AAOA,MAAMa,gBAAgB,GAAIC,OAAD,IAAa;AAClC,SAAO,EACH,GAAGA,OADA;AAEHT,IAAAA,kBAAkB,EAAGS,OAAO,CAACT,kBAAR,KAA+BC,SAAhC,GAChBQ,OAAO,CAACT,kBADQ,GAEfS,OAAO,CAACX,cAAR,KAA2B,CAA3B,IAAgCW,OAAO,CAACV,eAAR,KAA4B,CAA7D;AACI;;;;;AAKA,KAACU,OAAO,CAACd,YAAT,CANJ,GAOIS,kBAAkB,CAACK,OAAO,CAACV,eAAT;AAXvB,GAAP;AAaH,CAdD;;AAeA,OAAO,MAAMW,iCAAiC,GAAG,CAACC,6BAAD,EAAgCC,oBAAhC,EAAsDC,gBAAtD,EAAwEC,8BAAxE,EAAwGC,4BAAxG,EAAsIC,gBAAtI,EAAwJC,2BAAxJ,EAAqLC,iCAArL,EAAwNC,iBAAxN,KAA8O;AAC3R,SAAO,MAAMC,gBAAN,SAA+BR,oBAA/B,CAAoD;AACvDS,IAAAA,WAAW,CAACC,OAAD,EAAUC,IAAV,EAAgBd,OAAO,GAAGf,eAA1B,EAA2C;AAClD,YAAM8B,aAAa,GAAGR,gBAAgB,CAACM,OAAD,CAAtC;AACA,YAAMG,SAAS,GAAGR,2BAA2B,CAACO,aAAD,CAA7C;AACA,YAAME,aAAa,GAAGlB,gBAAgB,CAAC,EAAE,GAAGd,eAAL;AAAsB,WAAGe;AAAzB,OAAD,CAAtC;AACA,YAAMkB,iCAAiC,GAAGnC,uCAAuC,CAACoC,GAAxC,CAA4CJ,aAA5C,CAA1C;AACA,YAAMK,oBAAoB,GAAIF,iCAAiC,KAAK1B,SAAvC,GACzBA,SADyB,GAEzB0B,iCAAiC,CAACC,GAAlC,CAAsCL,IAAtC,CAFJ;AAGA,YAAMO,sBAAsB,GAAGf,4BAA4B,CAACS,aAAD,EAAgBC,SAAS,GAAG,IAAH,GAAUH,OAAO,CAACS,WAA3C,EAAwDb,iCAAxD,EAA2FK,IAA3F,EAAiGM,oBAAjG,EAAuHH,aAAvH,CAA3D;AACA,YAAMM,wBAAwB,GAAKP,SAAD,GAC5BX,8BAA8B,CAACS,IAAD,EAAOG,aAAP,EAAsBG,oBAAtB,CADF,GAE5B,IAFN;AAGA;;;;;AAIA,YAAMP,OAAN,EAAe,IAAf,EAAqBQ,sBAArB,EAA6CE,wBAA7C;AACA,YAAMC,UAAU,GAAG,EAAnB;AACAH,MAAAA,sBAAsB,CAACG,UAAvB,CAAkCC,OAAlC,CAA0C,CAACC,gBAAD,EAAmBC,EAAnB,KAA0B;AAChE,cAAMC,UAAU,GAAGxB,gBAAgB,CAAC,IAAD,EAAOY,SAAP,EAAkBU,gBAAlB,CAAnC;AACAF,QAAAA,UAAU,CAAC1B,IAAX,CAAgB,CAAC6B,EAAD,EAAKC,UAAL,CAAhB;AACH,OAHD;AAIA,WAAKC,uBAAL,GAA+BR,sBAA/B;AACA,WAAKS,iBAAL,GAAyB,IAAzB;AACA,WAAKC,WAAL,GAAmB,IAAI/C,WAAJ,CAAgBwC,UAAhB,CAAnB;AACA;;;;;AAIA,UAAIR,SAAJ,EAAe;AACXd,QAAAA,6BAA6B,CAACa,aAAD,EAAgB,IAAhB,CAA7B;AACH;AACJ;;AACD,QAAIiB,gBAAJ,GAAuB;AACnB,aAAO,KAAKF,iBAAZ;AACH;;AACD,QAAIE,gBAAJ,CAAqBC,KAArB,EAA4B;AACxB,YAAMC,eAAe,GAAI,OAAOD,KAAP,KAAiB,UAAlB,GAClBvB,iBAAiB,CAAC,IAAD,EAAOuB,KAAP,CADC,GAElB,IAFN;AAGA,WAAKJ,uBAAL,CAA6BG,gBAA7B,GAAgDE,eAAhD;AACA,YAAMC,sBAAsB,GAAG,KAAKN,uBAAL,CAA6BG,gBAA5D;AACA,WAAKF,iBAAL,GAA0BK,sBAAsB,KAAK,IAA3B,IAAmCA,sBAAsB,KAAKD,eAA/D,GACnBD,KADmB,GAEnBE,sBAFN;AAGH;;AACD,QAAIX,UAAJ,GAAiB;AACb,UAAI,KAAKO,WAAL,KAAqB,IAAzB,EAA+B;AAC3B;AACA,eAAO,KAAKF,uBAAL,CAA6BL,UAApC;AACH;;AACD,aAAO,KAAKO,WAAZ;AACH;;AACD,QAAIK,IAAJ,GAAW;AACP,aAAO,KAAKP,uBAAL,CAA6BO,IAApC;AACH;;AAxDsD,GAA3D;AA0DH,CA3DM","sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: (options.outputChannelCount !== undefined) ?\n            options.outputChannelCount :\n            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?\n                /*\n                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                 */\n                [options.channelCount] :\n                createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, wrapEventListener) => {\n    return class AudioWorkletNode extends audioNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = (nodeNameToProcessorConstructorMap === undefined) ?\n                undefined :\n                nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline)\n                ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor)\n                : null);\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, this);\n            }\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = (typeof value === 'function')\n                ? wrapEventListener(this, value)\n                : null;\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = (nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener)\n                ? value\n                : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2019/factories/audio-worklet-node-constructor.js.map"]},"metadata":{},"sourceType":"module"}