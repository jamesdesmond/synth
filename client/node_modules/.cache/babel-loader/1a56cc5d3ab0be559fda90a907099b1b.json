{"ast":null,"code":"import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n  const trace = [];\n  return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination).render(destination, nativeOfflineAudioContext, trace)\n  /*\n   * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n   * destination.\n   */\n  .then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(audioWorkletNode => getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext, trace)))).then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext)).then(audioBuffer => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n    if (typeof audioBuffer.copyFromChannel !== 'function') {\n      wrapAudioBufferCopyChannelMethods(audioBuffer);\n      wrapAudioBufferGetChannelDataMethod(audioBuffer); // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n    } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n      wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n    }\n\n    audioBufferStore.add(audioBuffer);\n    return audioBuffer;\n  });\n};","map":{"version":3,"sources":["/Users/jamescoyne/Desktop/synth-master/client/node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js"],"names":["wrapAudioBufferGetChannelDataMethod","createStartRendering","audioBufferStore","cacheTestResult","getAudioNodeRenderer","getUnrenderedAudioWorkletNodes","renderNativeOfflineAudioContext","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","trace","destination","nativeOfflineAudioContext","render","then","Promise","all","Array","from","map","audioWorkletNode","audioBuffer","copyFromChannel","add"],"mappings":"AAAA,SAASA,mCAAT,QAAoD,sDAApD;AACA,OAAO,MAAMC,oBAAoB,GAAG,CAACC,gBAAD,EAAmBC,eAAnB,EAAoCC,oBAApC,EAA0DC,8BAA1D,EAA0FC,+BAA1F,EAA2HC,mDAA3H,EAAgLC,iCAAhL,EAAmNC,4CAAnN,KAAoQ;AACpS,QAAMC,KAAK,GAAG,EAAd;AACA,SAAO,CAACC,WAAD,EAAcC,yBAAd,KAA4CR,oBAAoB,CAACO,WAAD,CAApB,CAC9CE,MAD8C,CACvCF,WADuC,EAC1BC,yBAD0B,EACCF,KADD;AAE/C;;;;AAF+C,GAM9CI,IAN8C,CAMzC,MAAMC,OAAO,CAClBC,GADW,CACPC,KAAK,CACTC,IADI,CACCb,8BAA8B,CAACO,yBAAD,CAD/B,EAEJO,GAFI,CAECC,gBAAD,IAAsBhB,oBAAoB,CAACgB,gBAAD,CAApB,CAC1BP,MAD0B,CACnBO,gBADmB,EACDR,yBADC,EAC0BF,KAD1B,CAFtB,CADO,CANmC,EAW9CI,IAX8C,CAWzC,MAAMR,+BAA+B,CAACM,yBAAD,CAXI,EAY9CE,IAZ8C,CAYxCO,WAAD,IAAiB;AACvB;AACA;AACA,QAAI,OAAOA,WAAW,CAACC,eAAnB,KAAuC,UAA3C,EAAuD;AACnDd,MAAAA,iCAAiC,CAACa,WAAD,CAAjC;AACArB,MAAAA,mCAAmC,CAACqB,WAAD,CAAnC,CAFmD,CAGnD;AACH,KAJD,MAKK,IAAI,CAAClB,eAAe,CAACI,mDAAD,EAAsD,MAAMA,mDAAmD,CAACc,WAAD,CAA/G,CAApB,EAAmJ;AACpJZ,MAAAA,4CAA4C,CAACY,WAAD,CAA5C;AACH;;AACDnB,IAAAA,gBAAgB,CAACqB,GAAjB,CAAqBF,WAArB;AACA,WAAOA,WAAP;AACH,GAzBkD,CAAnD;AA0BH,CA5BM","sourcesContent":["import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) => {\n    const trace = [];\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext, trace)\n        /*\n         * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n         * destination.\n         */\n        .then(() => Promise\n        .all(Array\n        .from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext))\n        .map((audioWorkletNode) => getAudioNodeRenderer(audioWorkletNode)\n        .render(audioWorkletNode, nativeOfflineAudioContext, trace))))\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #157: Only Chrome & Opera do allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=/build/es2019/factories/start-rendering.js.map"]},"metadata":{},"sourceType":"module"}